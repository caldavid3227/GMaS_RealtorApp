"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs-extra");
const chalk = require("chalk");
const dateFns = require("date-fns");
const pathHelper_1 = require("./../helpers/pathHelper");
const utils_1 = require("./../helpers/utils");
const envHelper_1 = require("../helpers/envHelper");
const config_1 = require("../config/config");
const packagesHelper_1 = require("../helpers/packagesHelper");
const install_1 = require("../scripts/install");
const build_1 = require("../scripts/build");
exports.default = {
    command: 'deploy [command]',
    describe: 'Deploy project for production',
    handler: commandHandler,
    builder: commandBuilder
};
const TARGET_HEROKU = 'heroku';
const TARGET_LOCAL = 'local';
const TARGET_NOW = 'now';
const COMMAND_STOP = 'stop';
const COMMAND_INIT = 'init';
const VALID_TARGETS = [TARGET_LOCAL, TARGET_HEROKU, TARGET_NOW];
const VALID_COMMANDS = [COMMAND_STOP, COMMAND_INIT];
function commandBuilder(yargs) {
    return yargs
        .option('stop', {
        description: 'Stop running application process for local deployment'
    })
        .option('target', {
        alias: 't',
        description: 'Deployment target, supported targets are heroku/now/local, local is deafult'
    })
        .option('instance', {
        alias: 'i',
        description: 'For heroku only, specify instance name (dev, production, etc)'
    })
        .option('heroku-app', {
        alias: 'happ',
        description: 'For heroku only, specify Heroku App ID'
    })
        .option('skip-client-build', {
        alias: 'scb',
        description: 'Skip client build'
    })
        .example('deploy', 'Deploy project for production (starts project with one of supported process managers).')
        .example('deploy --stop', 'Stop running app (it is removed from process list and cannot be restarted again).')
        .example('deploy -t heroku -i dev -happ my-heroku-app', 'Deploys app to heroku server using dev instance, which corresponds to heroku APP_ID "my-heroku-app".');
}
function commandHandler(argv) {
    return __awaiter(this, void 0, void 0, function* () {
        envHelper_1.default.checkFolderStructure();
        let processManager = detectProcessManager();
        let appName = envHelper_1.default.getAppName();
        let instance = argv.instance;
        if (argv.stop) {
            return utils_1.default.logOperation(`Stop '${appName}' application process`, () => {
                stopLocalApp(processManager, appName);
            });
        }
        let target = getTarget(argv);
        let deployDir = pathHelper_1.default.projectRelative(config_1.default.paths.deploy.root, target);
        let buildDir = pathHelper_1.default.projectRelative(config_1.default.paths.build.root);
        let deployParams = {
            target,
            appName,
            deployDir,
            buildDir,
            processManager,
            instance,
            argv
        };
        try {
            if (!utils_1.default.dirHasContent(deployDir)) {
                utils_1.default.ensureEmptyDir(deployDir);
            }
            beforeDeployInit(deployParams);
            beforeDeploy(deployParams);
            yield ensureBuild(argv.skipClientBuild);
            utils_1.default.logOperation('Copy build assets', () => {
                let isFirstDeploy = !fs.existsSync(deployDir);
                if (isFirstDeploy) {
                    utils_1.default.ensureEmptyDir(deployDir);
                }
                else {
                    let localDir = pathHelper_1.default.deployRelative(config_1.default.paths.server.local);
                    let gitDir = `!${deployDir}/.git`;
                    let ignoreList = [localDir, gitDir];
                    if (target === TARGET_NOW) {
                        ignoreList.push('now.json');
                    }
                    utils_1.default.clearDir(deployDir, ignoreList);
                }
                fs.copySync(buildDir, deployDir);
            });
            afterDeploy(deployParams);
        }
        catch (err) {
            utils_1.default.logAndExit(err);
        }
    });
}
function getTarget(argv) {
    let target = TARGET_LOCAL;
    if (argv.target) {
        utils_1.default.assertValueIsInTheList(argv.target, VALID_TARGETS, `Invalid deploy target.`);
        target = argv.target;
        if (target === TARGET_HEROKU) {
            if (!argv.instance) {
                utils_1.default.logAndExit('Specify instance for heroku deployments');
            }
        }
    }
    return target;
}
function beforeDeployInit(deployParams) {
    const { target, processManager, appName, instance, deployDir, argv } = deployParams;
    switch (target) {
        case TARGET_LOCAL:
            break;
        case TARGET_HEROKU:
            let gitCommand = (args, title = '', allowError = false) => utils_1.default.runCommand('git', args, {
                title,
                path: deployDir,
                ignoreError: true
            });
            let hasGitFolder = fs.existsSync(pathHelper_1.default.path.join(deployDir, '.git'));
            if (!hasGitFolder) {
                gitCommand(['init']);
                let copyAsset = (from, to) => {
                    let assetName = `./assets/deploy/heroku/${from}`;
                    let fromPath = pathHelper_1.default.moduleRelative(assetName);
                    let toPath = pathHelper_1.default.path.join(deployDir, to);
                    fs.copySync(fromPath, toPath);
                };
                copyAsset('dummyPackage.json', 'package.json');
                copyAsset('dummyServer.js', 'index.js');
                gitCommand(['add', '.']);
                gitCommand(['commit', '-am', 'initial (dummy) deployment']);
            }
            let remoteExists = () => {
                let output = utils_1.default.getCommandOutput('git', ['rev-parse', '--verify', '--quiet', instance], deployDir);
                return output.output ? true : false;
            };
            let remoteHasMaster = () => {
                let output = utils_1.default.getCommandOutput('git', ['ls-remote', '--heads', instance, 'master'], deployDir);
                return output.output ? true : false;
            };
            if (!remoteExists()) {
                let herokuAppId = argv.herokuApp;
                if (!herokuAppId) {
                    utils_1.default.logAndExit('Specify Heroku App ID (--heroku-app) for initial deployment (see "deploy" command help for more information)');
                }
                utils_1.default.runCommand('heroku', ['git:remote', '-a', herokuAppId, '-r', instance], {
                    title: `Init local branch for instance ${instance}`,
                    path: deployDir
                });
                if (!remoteHasMaster()) {
                    gitCommand(['push', instance, 'master'], 'Doing Heroku initial (dummy) deployment');
                }
                gitCommand(['fetch', instance]);
                gitCommand(['checkout', `${instance}/master`, '-b', instance]);
            }
            break;
    }
}
function beforeDeploy(deployParams) {
    const { target, processManager, appName, instance, deployDir } = deployParams;
    switch (target) {
        case TARGET_LOCAL:
            stopLocalApp(processManager, appName);
            break;
        case TARGET_HEROKU:
            utils_1.default.runCommand('git', ['checkout', instance], {
                title: `Switch to "${instance}" branch`,
                path: deployDir
            });
            break;
        case TARGET_NOW:
            let nowConfig = getNowConfig(deployDir);
            let nowAppName = nowConfig.name;
            if (!nowAppName)
                utils_1.default.logAndExit('Specify now deployment name in now.json config.');
            utils_1.default.runCommand('now', ['rm', nowAppName, '-y'], {
                title: `Remove previous now deployments`,
                path: deployDir
            });
            break;
    }
}
function afterDeploy(deployParams) {
    const { target, processManager, appName, instance, deployDir } = deployParams;
    switch (target) {
        case TARGET_LOCAL:
            //install packages there
            let installCommandInfo = packagesHelper_1.default.getInstallPackagesCommand();
            utils_1.default.runCommand(installCommandInfo.command, installCommandInfo.params, {
                title: 'Install production dependencies',
                path: deployParams.deployDir
            });
            startLocalApp(processManager, appName);
            break;
        case TARGET_HEROKU:
            utils_1.default.runCommand('git', ['pull', instance], {
                title: `Pull changes from remote`,
                path: deployDir
            });
            utils_1.default.runCommand('git', ['add', '.'], {
                title: 'Add files to git',
                path: deployDir
            });
            utils_1.default.runCommand('git', ['commit', '-m', `"Deployment at ${dateFns.format(new Date(), 'YYYY-MM-DDTHH:mm:ss')}"`], {
                title: 'Commit files to git',
                ignoreError: true,
                path: deployDir
            });
            utils_1.default.runCommand('git', ['push', instance, `${instance}:master`], {
                title: 'Deploying to Heroku...',
                showOutput: true,
                path: deployDir
            });
            break;
        case TARGET_NOW:
            utils_1.default.runCommand('now', ['-y', '--public'], {
                path: deployDir,
                title: 'Deploy to Now',
                showOutput: true
            });
            let nowConfig = getNowConfig(deployDir);
            if (nowConfig.alias) {
                utils_1.default.runCommand('now', ['alias'], {
                    path: deployDir,
                    title: 'Add alias',
                    showOutput: true
                });
            }
            break;
    }
}
function ensureBuild(skipClientBuild) {
    //return Promise.resolve(null);
    install_1.default.installAll();
    return build_1.default.build(skipClientBuild ? 'server' : 'full');
}
function detectProcessManager() {
    let processManager = utils_1.default.findGlobalCommandByPrecedence(['pm2', 'forever']);
    if (!processManager) {
        utils_1.default.logAndExit(`Install globally one of supported process managers: forever or pm2.`);
    }
    return processManager;
}
function stopLocalApp(processManager, appName) {
    let params = [];
    if (processManager === 'forever') {
        params = ['stop', appName];
    }
    if (processManager === 'pm2') {
        params = ['delete', appName];
    }
    utils_1.default.runCommand(processManager, params, {
        path: getLocalDeploymentDir(),
        ignoreError: true,
        showOutput: false
    });
}
function startLocalApp(processManager, appName) {
    let params = [];
    if (processManager === 'forever') {
        params = ['start', '--id', appName, 'index.js'];
    }
    if (processManager === 'pm2') {
        params = ['start', 'index.js', '--name', appName];
    }
    utils_1.default.runCommand(processManager, params, {
        title: 'Start process',
        path: getLocalDeploymentDir()
    });
    utils_1.default.logAndExit(`Process has been started. By default it is available on ${chalk.cyan('http://localhost:5000')}.`);
}
function getLocalDeploymentDir() {
    return pathHelper_1.default.projectRelative(config_1.default.paths.deploy.root, TARGET_LOCAL);
}
function getNowConfig(deployDir) {
    let nowConfigPath = pathHelper_1.default.path.join(deployDir, 'now.json');
    if (!fs.existsSync(nowConfigPath))
        utils_1.default.logAndExit('Create now.json configuration file in deployment folder.');
    let nowConfig = fs.readJsonSync(nowConfigPath);
    return nowConfig;
}
//# sourceMappingURL=deploy.js.map